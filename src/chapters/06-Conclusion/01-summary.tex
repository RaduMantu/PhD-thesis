\section{Thesis Summary}
\label{conclusion:summary}

In Chapter \ref{background:chapter} we presented a state of the art overview of
industrial firealling technologies that perform application identification.
Because their implementation is proprietary and closed source, we baseed our
assessment on technical briefs and the official documentation. This overview was
meant to present the overall capabilities of existing technology with the
purpose of better distinguishing our proposed solution. Additionally, we
briefly describe the Netfilter system, how firewalling is implemented on Linux
and how \texttt{Netfilter Queue} integrates in this framework. In the second
part of this chapter we described the mechanisms designed for extending the IP,
TCP and UDP protocols. This subsection was intended as a primer, so it only
covers the basic mechanisms involved.

In Chapter \ref{extend:chapter} we explored the viability of using protocol
options as a conduit for attributing originating process identity information
to network traffic. Additionally, we investigated the challenges that may arise
if fuzzing was to be employed for guaranteeing the soundness of whitelisted
applications. This was achieved by means of a state-of-the-art survey regarding
network fuzzing. Meanwhile, the former of the two objectives was accomplished by
performing IP, TCP and UDP options acceptance tests in the Internet. For this
purpose, we created \texttt{ops-inject}, a packet annotation tool that either
created or replaced existing options with a sequence of TLV tuples arbitrarily expanded
framework a series of user-specified codepoints. Our experiments focused on measuring
successful packet traversal of public networks while carrying different options.
To this end, we have staged all-to-all experiments between 21 servers hosted
locally in our university and across multiple georgraphic regions, from four
different cloud providers: Microsoft Azure, AWS, Google Cloud and Digital Ocean.

Chapter \ref{appfw:chapter} presents two distinct implementations of our
firewalling engine: one implemented as a userspace process with eBPF syscall
probes, the other implemented as a kernel module with jump optimized kprobe
instrumentation. Our initial design focused on ease of adoption. We considered
a heavily constrained deployment environment, whose kernel was under lockdown.
As a result, our first prototype \daf{} collected system-level information about
running processes using established methods (e.g., the Netlink Socket Diagnostics
subsystems). The actual packet interception, analysis, and optional alteration
were performed using \texttt{Netfilter Queue}. This system is part of the larger
Netfilter framework and acts as the backend of the data acquisition library
(i.e., \texttt{libDAQ}) for \texttt{snort3} when operating in Intrusion Prevention
Mode. After significant efforts towards optimizing \daf{} we obtained near linerate
throughputs on a 10Gbps NIC. In order to offer a performant solution without
further compromising security guarantees, we decided to relax our initial
assumptions and decided to allow using Linux Kernel Modules. Thus we reimplemented
the most critical features in \daf{} in a new version that we called \scout{}.
This new iteration starts recording information about memory mapped executable
sections as soon as it is inserted. This data is acquired by intercepting
the \texttt{mmap()} and related system calls by means of dynamic instrumentation
of their common sub-routines. Due to its intrinsic parallelization and lack
of context switches for verdict communications, \scout{} effortlessly obtained
linerate throughput on the same 10Gbps system and with no noticeable overhead
during the process launch phase.

In Chapter \ref{sign:chapter} we described the distributed aspect of our firewall.
Specifically, we presented the structure of our SHA256-HMAC based tag that we
attached to each packet, differentiated between IP, TCP and UDP options and
introduced two implementations. One of them was a component of \daf{}, was specific
to Linux and utilized IP options as a conduit. The other was a standalone Windows
driver that integrated with the Windows Filter Engine and used TCP options as
a conduit. The difference in protocol choice was meant to demonstrate that
although we chose IP options due to them seamlessly covering all Layer 4
protocols, switching to TCP options can be viable if the network conditions are
adverse to our preferred conduit. In this chapter we also presented our
\texttt{iptables} and \texttt{snort3} plugins that can be used for tag
verification purposes. These plugins permit our firewall to be executed on a
subset of hosts where most of the traffic originates. The tag verification can
be performed on the path by middleboxes, without requiring the installation of
additional dependencies in order to run our firewall. Finally, we discussed the
challenges we faced when trying to integrate GPGME in \daf{} and presented a bug
we discovered inside the \texttt{Netfilter Queue} kernel module. We have
confirmed that under certain conditions, this bug may allow modified packets to
present malformed Layer 4 headers to \texttt{iptables} match functions on the
\texttt{POSTROUTING} chain. This aspect is not central to this thesis and is
discussed further in Section \ref{conclusion:future}.

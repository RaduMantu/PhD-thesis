\section{Related Work}
\label{appfw:relwork}

% The Xen-based application-level firewall
In 2008, Srivastava et al. proposed \texttt{VMwall} \cite{srivastava2008tamper}, a Xen-based application-level firewall running in dom0. This level of isolation was considered necessary due to the possibility of guest domains being infected, in which case the firewall itself would be considered compromised. VMwall is comprised of a kernel module capable of queuing packets from a certain source, and a user-agent that is consulted on newly initiated connections with the purpose of assessing their legitimacy. The user-agent leverages VM introspection (i.e., direct VM memory access) to identify the owner process of the socket bound on the source port of the initial packet. Once this process is determined, the mapped executable files are retrieved by performing a page table walk for the given process. Eventually, the decision of allowing the connection to be established is made based on the name of the underlying executable. Although \texttt{VMwall} presents a smaller attack surface and has a lower impact on throughput, our solutions provide a stronger assurance against attackers capable of hijacking the originating process at arbitrary moments in time (i.e., even after the connection was established). Furthermore, our solutions permits finer grained application filtering, based on the hashes of its memory mapped objects, also taking into account the realities of socket sharing.

% Distributed Information Flow Control
\texttt{DStar} \cite{zeldovich2008securing} is a Distributed Information Flow Control (DIFC) system that extends local implementations of specialized operating systems such as \texttt{HiStar} \cite{zeldovich2011making} and Flume \cite{krohn2007information}, as well as Linux, over a network. In \texttt{DStar}, all network communication is tagged with labels that either restrict it or grant other processes privileges over the data they receive. This solution is similar to \daf{} in that it requires the traffic passing through a component that enforces these constraints (i.e., the exporter daemon). One notable difference however, is that under \texttt{DStar} each process is responsible for appending its label to the generated traffic as part of the payload. Moreover, the process itself is permitted to downgrade its own label in order to establish communication with other processes. Both \daf{} and \scout{} do not rely on the applications to obey their information flow restrictions. In stead, these are enforced by our equivalent of the exporter daemon in a manner that is transparent to the endpoint processes.

% Practical DIFC Enforcement on Android
\texttt{Weir} \cite{nadkarni2016practical} is a DIFC system aimed at Android-based environments. If compared to the alternatives available at that time, \texttt{Weir} significantly reduces the burden placed on the system in order to ensure the successful enforcement of multiple secrecy contexts for individual applications. This is achieved by means of polyinstantiation, i.e., resource duplication (e.g., process, storage, etc.) to match a certain secrecy context, in lieu of limiting multitasking. Another issue that \texttt{Weir} attempts to solve is limiting data leakage to external entities. While DStar is similar in that in needs to establish trust in the remote exporter daemon before allowing its processes to establish connections, its approach is not suited for Internet-driven environments. Nadkarni et al. acknowledge that a significant number of systems that a regular user interacts with fall outside their Trusted Computing Base (TCB). Thus they provide a primitive named domain declassification that serves as an information flow constraint which places trust in the receiver of the data, rather than the sender. We agree that obstructing Internet communication due to an inability to authenticate the receiver is not practical. Nonetheless, we also acknowledge that assessing the identity of a remote endpoint (that falls outside our TCB) can not be done reliably. As a result, \daf{} is only able to assert its trust in the sender when operating independently. However, when \daf{} runs on both endpoints and both instances are configured by the same central entity, our system becomes able to strictly enforce communication between two specific applications (determined not by name, but by their comprising object files). We discuss this topic at length in Chapter \ref{sign:chapter}.

% Implementing a Distributed Firewall
In 2000, Ioannidis et al. \cite{ioannidis2000implementing} called to attention a number of then-quickly aggravating issues in the design of perimeter firewalls. Specifically, they foresaw difficulties in matching line rates when implementing support for computationally intensive protocols (e.g., IPsec), as well as furthering the phenomenon of protocol ossification \cite{turner2005diversifying} and proliferation of application-level proxies due to a lack of flexibility in configuration. But most notably, they challenged the idea that all internal hosts are to be implicitly trusted. Additionally, they argued that further segregating the internal network by deploying additional layers of firewalls was not a scalable solution. We note that this latter affirmation has been a matter of debate as of late \cite{bagheri2020dynamic}. Nonetheless, the authors introduced a distributed firewall scheme that transferred the responsibility of traffic validation to individual hosts. In this scheme, they relied on Keynote and IPsec for attesting to the authenticity of either endpoint and ensuring a secure communication channel. While key management falls beyond the scope of this paper, we contend that using encrypted channels may not necessarily be beneficial in certain cases. In our view, a distributed firewall should ensure authentication and integrity, but not necessarily confidentiality as well.

% Using trustworthy host-based information in the network
\texttt{Assayer} \cite{parno2012using} is a solution dating from 2012 by Parno et al. that leveraged host-based hardware security systems in order to extend the assurances they provided over a computer network. The authors implemented modular counters that would track application-specific information, to later be appended to network traffic. E.g., the average length of emails to detect spam, or the number of hosts contacted to identify network-scanning malware. As a means to provide isolation to these modules from the applications that they are monitoring, a minimal hypervisor (MiniVisor) was added to the architecture. In addition to separating these components, MiniVisor also accomplished a periodic negotiation with a Verifier (i.e., a separate entity located within the network that assesses the authenticity and integrity of the hypervisor and client modules via a TPM). Following a successful attestation, the initiator would receive a Sender Token that could be used in signing the annotated packet. The main difference between \texttt{Assayer} and our solutions is that neither MiniVisor nor the kernel enforce the traffic annotation scheme. As a result, each application must be aware of this service and opt into using it. Additionally, their annotation scheme does not conform to existing protocol extension standards, meaning its utilization should be predicated by a negotiation phase between endpoint applications lest it broke the application-level communication.

% Dymo: Tracking Dynamic Code Identity
\texttt{Dymo} \cite{gilbert2011dymo} is a system that implements a code identity primitive that can generate application-specific labels. These labels reflect the state of the executable memory pages of the process (i.e., both the base binary and libraries) and can be updated as to account for runtime alterations. While the authors take into account JIT-ed code, it does not influence the value of the label (i.e., a cryptographic hash over the executable memory pages) due to significant variations that may appear between subsequent runs. Instead, the kernel module tracks the DLL that performed the dynamic code generation. Additionally, Gilbert et al. provide an extension which allows the addition of the generated labels to network traffic as IP options. At a glance, the most significant difference between \texttt{Dymo} and \daf{} is that the former computes the cryptographic hashes over the virtual memory of the target process while the latter does so based on the backing files (i.e.: loaded from the file system). However, Dymo also proposes a \textit{relaxed matching policy} where only the executable sections of a subset of binaries are taken into consideration if code generation or selective library loading are encountered at runtime. Based on these two aspects, one can state that \scout{} adheres to the same design principles as \texttt{Dymo}. Another distinction that can be drawn between \daf{} and \texttt{Dymo} is that the latter is implemented as a kernel module on Windows XP. Although we set off with the goal of restricting \daf{} to user space, certain design decisions of Dymo are hard to replicate on Linux without modifying the kernel (e.g. hooking the Page Fault handler). Consequently, a direct port of Dymo would be even harder to integrate into existing software stacks while \daf{} was intended to be easily deployed on existing systems. Although \scout{} is also implemented as a kernel module, it leverages dynamic instrumentation to track the process of mapping executable sections into virtual memory, rather than monitoring page accesses via the page fault handler.

% Borderpatrol: Securing byod using fine-grained contextual information
\texttt{BorderPatrol} \cite{zungur2019borderpatrol} is a more recent attempt at annotating network traffic with application information to better enforce BYOD policies in corporate environments. Since it is specifically aimed at Android devices, it takes advantage of the Dalvik virtual machine and class metadata stored in \textit{.dex} files. Whenever a new application is introduced in the protected ecosystem, an Offline Analyzer parses to class metadata to create an indexed method database. On the users' devices, a Context Manager process monitors socket operations performed by all other applications and attaches the indices of the calling methods (that are deterministically calculated to match that of Offline Analyzer), together with the MD5 sum of the APK, as an IP option. The Context Manager relies on the Xposed Framework to attach to method and constructor hook points. This is done by replacing the method definitions in the Zygote process (i.e., a special process that spawns Dalvik VM instances and enables shared use of the core libraries; similar to a fork server). While \texttt{BorderPatrol} is used to block specific features that rely on network communication, these features are identified only by the method name and class path. This approach may have some merit against an unknowing assailant (e.g., mistakenly uploading company files to their personal cloud). However, an attacker may circumvent the Xposed Framework by either targeting an ELF binary (which is not forked from Zygote) or exploiting a vulnerability in the Dalvik VM.

